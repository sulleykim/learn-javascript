# 이벤트 루프

**Nodejs**는 대부분 **비동기 방식**으로 작동합니다. **동기와 비동기**는 무엇일까요?

## 동기와 비동기 방식

-   동기

> 순차적으로 작동

```javascript
var i;
for (i = 0; i < 5; i++) {
    console.log(i);
}

console.log("end");
```

```
0
1
2
3
4
end
```

-   비동기

> 특정 코드의 연산이 끝날때까지 코드의 실행을 멈추지않고 다음 코드를 먼저 실행하는 자바스크립트의 특성

```javascript
console.log("1");
setTimeout(function() {
    console.log("2");
}, 0);
console.log("3");
```

```
1
3
2
```

예제를 살펴본다면 충분히 차이점을 알 수 있습니다. 우리가 작성하게 될 **Nodejs**의 소스코드는 대부분 **비동기**입니다. 예제를 살펴보겠습니다.

```javascript
var fs = require("fs");

// non-blocking code
fs.readdir(".", function(err, filenames) {
    // callback
});

console.log("can process next job...");
```

자바스크립트를 잘 아신다면 자바스크립트의 특성중에 하나가 **비동기 방식**이라는 것을 잘 알고 있을 것입니다. 이것을 계속 강조하는 이유는 매우 중요하기 때문입니다.

## Nodejs에서 비동기

우리는 **Nodejs**에서 비동기 코드를 처리하는 방법이나 이와 관련된 지식 기반에 대해서 알아볼 것입니다. 비동기 처리의 핵심 키워드는 **이벤트 루프**입니다.

### 프로세스와 스레드

-   프로세스

> 운영체제로부터 시스템 자원을 할당받는 작업의 단위

-   스레드

> 프로세스내에서 실행되는 여러 흐름의 단위

우리가 컴퓨터에서 프로그램을 실행할 때마다 우리는 **프로세스**라고 불리는 것을 시작합니다. **프로세스**는 단일 프로세스 내에서 실행된 컴퓨터 프로그램의 인스턴스입니다.(실행중인 프로그램을 의미하기도 합니다.) 우리는 **스레드**라는 프로세스내에서 실행되는 여러 실행 흐름을 가질 수도 있습니다.

![스레드](https://user-images.githubusercontent.com/27342882/51316764-fc320b00-1a98-11e9-9c71-fb6bcf6a347e.JPG)

## 멀티 스레드에서 중요한 것

기본적으로 프로세스당 최소 1개의 스레드를 가지고 있고 그것을 **메인 스레드**라고 합니다. 프로세스는 1개 이상의 스레드를 가질수 있으며 **멀티스레드**라고 합니다. 멀티스레드에서 중요한 과제는 **스케줄링**입니다. 운영체제의 관리로 인해 주어진 시점에 처리할 수 있는 스레드를 결정할 수 있습니다.

## 많은 프로세스가 동시에 처리되어야 한다면

운영체제에서는 다양한 프로세스를 동시에 실행할 수 있습니다. 우리가 음악을 들으며 프로그래밍을 할 수 있는 이유는 운영체제가 스케줄링을 통해서 동시 작업을 지원하고 있기에 가능합니다. 작업 관리자를 통해서도 쉽게 수 많은 프로세스와 스레드가 동시에 실행되고 있다는 사실을 알 수 있습니다.

![작업 관리자](https://user-images.githubusercontent.com/27342882/51426168-f0c21980-1c29-11e9-86c5-0d39c72e474b.png)

**CPU**는 메인 메모리에 올라와있는 다양한 프로세스 또는 명령어 단위를 짧은 시간동안 점유하고 해체하는 작업을 통해서 모든 프로그램이 동시에 실행되고 있는 것처럼 느끼게 합니다. 실제로는 이것은 동시에 실행되는 것이 아닙니다. 단지, **CPU**가 사람이 느끼지 못할만큼 빠른 속도로 스케줄링하며 다양한 프로세스를 처리하고 있는 것입니다.

이 상태에서는 아무런 문제가 없어보입니다. 하지만 실제 컴퓨팅 환경에서는 CPU를 여러개 사용합니다. 그 이유는 다양하지만 주로 연산 속도가 관련이 있습니다. 그리고 1개의 CPU가 프로세스를 처리하는 것보단 당연히 2개의 CPU가 처리하는게 더 빠를 것입니다. 하지만 운영체제는 더 복잡해지겠지만요.

## 우리가 알고 있는 자바스크립트 이벤트 루프 매커니즘에 대하여

## Node 프로그램의 이벤트 루프에 대하여 알아보자

![Nodejs 이벤트 루프](https://user-images.githubusercontent.com/27342882/51439607-3f41e780-1d00-11e9-9465-19928007147d.JPG)

노드(Node) 프로그램을 실행하면 자동으로 하나의 스레드가 생성되고 단일 스레드 내부의 파란색 상자가 나타내는 영역에 이벤트 루프가 존재하게 됩니다. 이벤트 루프는 스레드가 무엇을 해야하는지 결정하는 제어구조와 같습니다. 이 이벤트 루프는 노드(Node) 프로그램의 핵심이며 그림에서 보듯이 정확히 하나의 이벤트 루프를 가지고 있습니다. 이벤트 루프가 어떻게 작동하는지 이해하는 것은 매우 중요합니다. 노드에 대한 많은 성능 우려가 결국 이벤트 루프의 작동 방식에 영향을 미칩니다. 따라서 본질적으로 이벤트 루프를 이해하면 성능을 이해할 수 있습니다. 하지만 이벤트 루프를 이해하는 것은 매우 어려운 일입니다. 많은 참고 자료가 있지만 여전히 이해하기 힘듭니다. 그래서 우리는 가짜(fake) 코드를 작성하려고 합니다. 우리는 작성한 가짜 코드를 통해 노드가 어떻게 작동하는지 알 수 있습니다.

```javascript
// node myFile.js

const pendingTimers = [];
const pendingOSTasks = [];
const pedingOperations = [];

function shouldContinue() {
    // 첫번째, 대기중인 모든 setTimeout, setInterval, setImmediate
    // 두번째, 대기중인 모든 OS 작업(포트를 수신하는 서버)
    // 세번째, 대기중인 장시간 작업(fs 모듈)
    return (pendingTimers.length || pendingOSTasks.length || pedingOperations.length);
}

while (shouldContinue()) {
    // 1) Node는 대기중인 Timer를보고 호출 할 준비가 된 함수가 있는지 확인합니다.

    // 2) 노드는 pendingOsTasks 및 보류중인 작업을 보고 관련 콜백을 호출합니다.

    // 3) 실행을 일시 중지합니다.
    // - 새로운 보류중인 OS 태스크가 완료되었습니다.
    // - 새로운 보류중인 작업이 완료되었습니다.
    // - 타이머가 곧 끝난다.

    // 4) 대기중인 타이머 함수를 살펴본다.

    // 5) 어떤 종료 이벤트를 다룬다.
}
// exit back to terminal
```

`while` 루프의 본문은 이벤트 루프에서 반복적으로 실행될 것입니다. 우리는 이와 같은 실행을 **tick**이라고 칭합니다. 따라서 이벤트 루프가 노드 응용 프로그램 내부에서 실행될 때마다 이를 한 번의 **tick**이라고합니다.

## 노드에 대한 오해

때때로 노드에 관한 게시글을 읽다보면 **단일 스레드 기반**이라는 구문을 강조하는 것을 살펴볼 수 있습니다. 하지만 이것은 오해입니다. 물론, 우리는 앞서 그림을 통해서 이벤트 루프를 하나만 사용한다고 알 수 있었습니다. 이에 관한 진실은 훨씬 복잡합니다. 그래서 우리는 지금 노드가 **단일 스레드**인지에 대해서 조사해볼 것입니다. 실제로 노드으 이벤트 루프는 싱글 스레드가 맞습니다. 하지만 어떤 노드 프레임워크 및 라이브러리는 싱글 스레드가 아닐 수 있다는 사실이 중요합니다. 그렇습니다. 이것은 사용하는 상황에 따라서 달라집니다. 아래 예제를 살펴보자.

```javascript
const crypto = require("crypto");

const start = Date.now();
crypto.pbkdf2("a", "b", 100000, 512, "sha512", () => {
    console.log("1:", Date.now() - start);
});

crypto.pbkdf2("a", "b", 100000, 512, "sha512", () => {
    console.log("2:", Date.now() - start);
});

// 1: 1150
// 2: 1159
```

예제 소스코드의 결과를 보면 예상 밖의 결과가 나오게 됩니다. 그 이유는 실행 시간 차이가 극심하게 나지 않기 때문입니다.

![노드가 싱글스레드라면](https://user-images.githubusercontent.com/27342882/51911406-12cf4f00-2415-11e9-923a-04cccab878b7.JPG)

우리는 두 함수가 순차적으로 실행되므로 대략 2초정도의 실행시간을 예상하였습니다. 하지만 실제 작동은 아래 그림과 같이 실행됩니다.

![실제 작동](https://user-images.githubusercontent.com/27342882/51911568-896c4c80-2415-11e9-8a70-a04487efc3a9.JPG)

우리가 현재까지 알고 있는 지식으로는 노드는 **싱글 스레드**이므로 실행 흐름이 하나뿐이여야 합니다. 하지만 그림에는 두 가지 함수가 동시에 실행되고 있는 것을 확인할 수 있습니다. 어떻게 된 것일까요?
